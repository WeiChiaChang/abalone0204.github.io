<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Text Mining & Analysis： week 1 · De-bug: 一鍵跑版</title><meta name="description" content="Text Mining &amp; Analysis： week 1 - Tsung-Chen Ku"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/customize.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abalone0204" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://twitter.com/TinyDenny" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/denny-ku-a9a21396?trk=hp-identity-name" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Text Mining & Analysis： week 1</h1><div class="post-time">Jul 15, 2016</div><div class="post-content"><p>最近對於 text mining 的知識頗有有需求，</p>
<p>所以開始上一門 coursera 上的課程，</p>
<p>主要在探討 text mining 和 分析，</p>
<p>會停留在比較 general purpose 的理論和演算法上，</p>
<p>乍看之下其實有點無聊，</p>
<p>但我覺得原因是課堂的教授預設我們有許多預備知識和對數學的靈敏度，</p>
<p>實際上它的內容非常的扎實，而且講解的也很深入，</p>
<p>經過我整理之後應該會變得好懂很多，</p>
<blockquote>
<p>因為我不像那些教授一樣是天才 XDD </p>
<p>大學也沒修過這類型的課程，只是因為興趣所以研究這個。</p>
<p>可能就如同每個在網路上看到這篇文章的人一樣。</p>
</blockquote>
<p>如果是跟我一樣的 NLP 新手，這一系列筆記應該會對你很有幫助，</p>
<p>並且成為你往更深層分析研究的基石。</p>
<a id="more"></a>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><blockquote>
<p>這裡推薦一下大家去看吳軍教授的「數學之美」，</p>
<p>裡面有提到相當多關於「語言」以及電腦科學在自然語言處理上的介紹。</p>
</blockquote>
<p>語言其實就是承載知識的載體，</p>
<p>仔細想一想我們其實能從大量的文本中整合出各式各樣的主題（topic），</p>
<p>甚至能從中汲取出作者的觀點來，</p>
<p>但是該怎麼做呢？</p>
<p>原本的自然語言處理領域認為，電腦要學會看文字，</p>
<p>應該要跟人類一樣從文法和字母開始學起，</p>
<p>但後來發現地球上有這麼多語言，每種語言又有特殊的文法，</p>
<p>而文法更是會隨著時代改變，</p>
<p>漸漸的，大家發現這條路好像不是這麼行得通。</p>
<blockquote>
<p>更別說有 context dependancy 的語法分析的時間複雜度高達 O(n^6)</p>
</blockquote>
<p>經過數十年在學術上的努力後，</p>
<p>終於發現用統計模型來讓電腦理解語言才是正途，</p>
<p>這也是現在在搜尋引擎中所用的技術之一，</p>
<p>而且無關什麼語言或是什麼樣的句法，</p>
<p>都能夠用統計語言模型的方法來表示。</p>
<blockquote>
<p>我想如果大學教授有跟我提這件事的話，</p>
<p>我現在可能就不會是個寫程式的人，會是個研究統計學的狂熱者了 XD</p>
</blockquote>
<p>這堂課主要就是做初步的去探討怎麼樣把「文本資料」，</p>
<p>轉換成我們能夠做運算的模型，</p>
<p>進而讓電腦理解。</p>
<p>有了這些基礎後，才能更簡單的運用電腦擅於運算的特性，</p>
<p>讓我們更快速的運用這些從文本上挖掘到的知識。</p>
<blockquote>
<p>這是一門專注在 shallow techniques 上面的課，</p>
<p>但內容可一點都不膚淺，後面會再提到何謂 shallow，何謂 deep。</p>
</blockquote>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><ul>
<li><p>流程：</p>
<ol>
<li><p>Natural language processing &amp; text representation</p>
</li>
<li><p>Word association mining &amp; analysis</p>
</li>
<li><p>Topic mining &amp; anaylysis</p>
</li>
<li><p>Opinioon mining &amp; sentiment analysis</p>
</li>
<li><p>Text-based prediction</p>
</li>
</ol>
</li>
</ul>
<p>來看一下流程圖：</p>
<p><img src="http://i.imgur.com/jobmiIH.png" alt="flow"></p>
<p>上述的流程中，</p>
<p>你會發現越前面的步驟其實需要越少人工介入，但沒辦法挖掘更深層的資訊，</p>
<p>越趨近於 shallow techniques。（不深嘛）</p>
<p>越後面則是越趨近於 deep techniques。（不淺嘛）</p>
<ul>
<li><p>Shallow techniques ，雖然得到的知識量比較少，但比較 general，不會因為領域不同被侷限，而且通常不需要或只需要相當少的人工介入（這門課裡面講的就是 shallow techniques）。</p>
</li>
<li><p>Deep techniques 需要人工介入，而且有更多局限性，但能獲取到更多的知識。</p>
</li>
<li><p>結合前兩者加上機器學習才能得到 actionable information（知道這些知識後，我們可以採取某些行動或決策）</p>
</li>
</ul>
<p>目前還沒有什麼兩全其美的方法，</p>
<p>在開始文本挖掘之前，建立好這個 trade-off 的概念是相當重要的。</p>
<h1 id="Text-Representation"><a href="#Text-Representation" class="headerlink" title="Text Representation"></a>Text Representation</h1><h2 id="Sequence-of-characters"><a href="#Sequence-of-characters" class="headerlink" title="Sequence of characters"></a>Sequence of characters</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A dog is chasing a boy on the playground</div></pre></td></tr></table></figure>
<blockquote>
<p>就是一連串的字元組合起來的字串，但對分析並沒有意義，</p>
<p>因為它沒有提供一個電腦能夠解析的結構。</p>
</blockquote>
<h2 id="Sequence-of-words-POS-Part-Of-Speech-tags"><a href="#Sequence-of-words-POS-Part-Of-Speech-tags" class="headerlink" title="Sequence of words + POS(Part-Of-Speech) tags"></a>Sequence of words + POS(Part-Of-Speech) tags</h2><blockquote>
<p>這是這一門課主要探討的範圍，其他可以稍微看看就好 XD</p>
<p>這一層是所有 text mining 的基石，後續的分析和 mining 都能與此有所關連</p>
</blockquote>
<p>為了得到更結構化的資料，我們可以試看看 POS(Part Of Speech) tags，</p>
<p>來為每個詞貼上一個 tag 看看，這個 tag 就是這個詞的詞性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">A: Det</div><div class="line"></div><div class="line">Dog: N</div><div class="line"></div><div class="line">is: Aux</div><div class="line"></div><div class="line">chasing: Verb</div><div class="line"></div><div class="line">a: Det</div><div class="line"></div><div class="line">boy: N</div><div class="line"></div><div class="line">on: PPrep</div><div class="line"></div><div class="line">the: Det</div><div class="line"></div><div class="line">playground: N</div></pre></td></tr></table></figure>
<p>POS tag 的優劣分析</p>
<ul>
<li><p>Pros:</p>
<ul>
<li><p>word 是人們溝通的基本單位</p>
</li>
<li><p>有了這個結構之後我們能統計每個字出現的次數</p>
</li>
<li><p>能夠被應用到 topic analysis 上</p>
</li>
</ul>
</li>
<li><p>Cons:</p>
<ul>
<li><p>不夠 general，像是中文就不是這樣認字。（中文字和中文字中間不會用空格分開）</p>
</li>
<li><p>解法：中文會需要自己的斷詞（e.q: 結巴）</p>
</li>
</ul>
</li>
</ul>
<h2 id="Syntatic-structures"><a href="#Syntatic-structures" class="headerlink" title="Syntatic structures"></a>Syntatic structures</h2><ul>
<li>一個表示語法的樹狀圖，這裡不會探討太多這部分，將會以統計模型表示語言的方式為主</li>
</ul>
<h2 id="Entities-and-relations"><a href="#Entities-and-relations" class="headerlink" title="Entities and relations"></a>Entities and relations</h2><ul>
<li><p>拆出這個句子裡有哪些「實體」與「關係」</p>
</li>
<li><p>e.q：我吃香蕉</p>
</li>
</ul>
<p>這裡的實體就是<code>我</code>、<code>香蕉</code>，</p>
<p>而我們的關係是 <code>吃</code>與<code>被吃</code>。</p>
<h2 id="Logic-predicates"><a href="#Logic-predicates" class="headerlink" title="Logic predicates"></a>Logic predicates</h2><ul>
<li>寫成 logic predicate：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog(d1). Boy(b1). Playground(p1). Chasing(d1, b1, p1)</div></pre></td></tr></table></figure>
<ul>
<li>經由 logic predicates 我們能做到一些更智能的判斷，而且電腦也開始懂我們在說什麼了。</li>
</ul>
<h2 id="Speech-acts"><a href="#Speech-acts" class="headerlink" title="Speech acts"></a>Speech acts</h2><ul>
<li><p>瞭解這句話的「意圖」（intent）是什麼，光用想的就非常困難</p>
</li>
<li><p>e.q：</p>
<ul>
<li>「假的！」這句話在海濤法師出來以前可能真的是指「這個東西不真實」，但現在卻不然</li>
</ul>
</li>
</ul>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><ul>
<li><p>越往下是越深層的分析和挖掘</p>
<ul>
<li><p>需要更多人工判斷</p>
</li>
<li><p>精確度其實是降低的</p>
</li>
<li><p>但是也越接近人類知識的表達</p>
</li>
</ul>
</li>
<li><p>繼續研究下去之前我們得了解會有這樣的 trade-off</p>
<ul>
<li><p>所以要想辦法在人的參與和機器學習間做優化</p>
<ul>
<li><p>想想要怎樣讓人工的部分更簡單、省事</p>
</li>
<li><p>利用上述的結果來得到更精確的學習結果、讓人工參與部分減少</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>這堂課主要就是以 shallow techniques 為主，</p>
<p>Shallow techniques 有以下幾個特點：</p>
<ul>
<li><p>General and robust</p>
</li>
<li><p>No/little manual effort</p>
</li>
<li><p>“Surprisingly” powerful</p>
</li>
<li><p>Can be combined with more sophisticated representations</p>
</li>
</ul>
<h1 id="Word-Association-Mining-and-Analysis"><a href="#Word-Association-Mining-and-Analysis" class="headerlink" title="Word Association Mining and Analysis"></a>Word Association Mining and Analysis</h1><p>有了基本的文字探勘概念以後，</p>
<p>要先了解的就是詞和詞之間的關係，</p>
<p>並且把它們用數學的方式來表達。</p>
<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul>
<li><p>什麼是 word association</p>
</li>
<li><p>為什麼要挖掘 word association</p>
</li>
<li><p>如何挖掘 word association</p>
</li>
</ul>
<h2 id="什麼是-word-association"><a href="#什麼是-word-association" class="headerlink" title="什麼是 word association"></a>什麼是 word association</h2><p>簡單說就是詞跟詞之間的關係，</p>
<p>有以下兩種：</p>
<ul>
<li><p>Paradigmatic Relation（聚合關係）</p>
<ul>
<li><p><code>A</code>,<code>B</code>兩個詞可以互相替換，那兩者就有 paradigmatic relation</p>
</li>
<li><p>從 similar context 去找: high context similarity =&gt; high paradigmatic relation</p>
</li>
<li><p>e.q: “cat” and “dog”</p>
</li>
</ul>
</li>
<li><p>Syntagmatic Relation（組合關係）</p>
<ul>
<li><p><code>A</code>,<code>B</code>兩個詞可以互相結合，那兩者就有 Syntagmatic relation</p>
</li>
<li><p>從 correlated occurence 去找: high co-occurences but relatively low individual occurences =&gt; high syntagmatic relation</p>
</li>
<li><p>e.q: “cat” nad “sit”, “car” and “drive”</p>
</li>
</ul>
</li>
</ul>
<h2 id="為什麼要挖掘-word-association"><a href="#為什麼要挖掘-word-association" class="headerlink" title="為什麼要挖掘 word association"></a>為什麼要挖掘 word association</h2><p>才能了解各個 document 間的關係，</p>
<p>容易去做 topic analysis，</p>
<p>要做更深層的分析前都得先做這一步。</p>
<h2 id="挖掘-Paradigmatic-Relation（聚合關係）"><a href="#挖掘-Paradigmatic-Relation（聚合關係）" class="headerlink" title="挖掘 Paradigmatic Relation（聚合關係）"></a>挖掘 Paradigmatic Relation（聚合關係）</h2><p>前面我們稍微理解了 Paradigmatic 以及 Syntagmatic 兩者的定義，</p>
<p>現在要來更深入的了解 Paradigmatic Relation。</p>
<p>首先要了解的概念是 Pseudo document，</p>
<p>讓我們用不同的方式來理解 context（上下文）。</p>
<p>Pseudo document，其實就是各式各樣的 bag of words，</p>
<p>裡面裝著各種「字」。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat: </div><div class="line">  My ___ eats fish on Saturday.</div><div class="line">  My ___ eats turkey on Sunday.</div></pre></td></tr></table></figure>
<p>Pseudo document 的表示方式就是像下面敘述的這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Left1(&quot;cat&quot;) = &#123;&quot;my&quot;, &quot;his&quot;, &quot;big&quot;, &quot;a&quot;, &quot;the&quot;,...&#125;</div><div class="line"></div><div class="line">Right1(&quot;cat&quot;) = &#123;&quot;eats&quot;, &quot;ate&quot;, &quot;is&quot;, &quot;has&quot;, ....&#125;</div><div class="line"></div><div class="line">Window10(&quot;cat&quot;) = &#123;&quot;my&quot;, &quot;his&quot;, &quot;big&quot;, &quot;eats&quot;, &quot;fish&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;...&#125;</div></pre></td></tr></table></figure>
<p>第一項 <code>Left1(&quot;cat&quot;)</code> 就是 cat 左邊的一個字能放什麼，</p>
<p><code>Right1</code> 則依此類推，</p>
<p>甚至我們也可以用 <code>Window10(&quot;cat&quot;)</code>來表示 10 個字裡面出現 cat 的 pseudo document，</p>
<blockquote>
<p>沒錯，window 10 </p>
</blockquote>
<p>所以 pseudo document 裡的字，</p>
<p>跟我們的目標字（這裡是 cat）相鄰或不相鄰都是可以的。</p>
<p>有了這些裝在袋子裡的字，我們就有了更堅實的基礎去比較 context 間的相似度。</p>
<p>以下用 Sim 這個 function 來表示 “Cat” 跟 “Dog” 的 context 相似度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sim(&quot;cat&quot;, &quot;dog&quot;) =</div><div class="line">  Sim(Left1(&quot;cat&quot;), Left1(&quot;dog&quot;))</div><div class="line">    + Sim(Right1(&quot;cat&quot;), Right1(&quot;dog&quot;)) +</div><div class="line">    ...</div><div class="line">    + Sim(Window8(&quot;cat&quot;), Window8(&quot;dog&quot;))</div></pre></td></tr></table></figure>
<p>context 有著越高的相似度，代表 “cat” 跟 “dog” 兩個字越有聚合關係。</p>
<blockquote>
<p>這裡並不是說一定要全部都算進去，我們也可以拿其中幾個袋子就好</p>
</blockquote>
<p>而要選擇用哪些袋子來分析相似度，更是大大影響了我們分析的結果，</p>
<p>假如我們使用的是 <code>Window10(&quot;cat&quot;)</code>，這個相對較寬鬆的條件，</p>
<p>我們得到的是更 general 的訊息，可能能有更廣泛的應用；</p>
<p>假如我們使用的是 <code>Left1(&quot;cat&quot;)</code> 這樣的 context 時，</p>
<p>只會知道 “cat” 左邊會出現什麼詞</p>
<p>得到的可能會是更趨近語法分析上的訊息，相較更侷限一些。</p>
<h3 id="Vector-space-model"><a href="#Vector-space-model" class="headerlink" title="Vector space model"></a>Vector space model</h3><p><img src="http://i.imgur.com/7Pw5kex.png" alt="vsm"></p>
<p>數學的美妙在於能把複雜的東西簡單化，</p>
<p>這裡我們很驚訝地發現能夠用 vector space 的方式來表現 context similarity</p>
<p>但問題來了，我們要怎樣去計算 <code>d1</code> 跟 <code>d2</code> 這兩個向量呢？</p>
<h3 id="Expected-Overlap-of-Words-in-Context-EOWC"><a href="#Expected-Overlap-of-Words-in-Context-EOWC" class="headerlink" title="Expected Overlap of Words in Context (EOWC)"></a>Expected Overlap of Words in Context (EOWC)</h3><p>其中一個相當直觀的方法是 Expected Overlap of Words in Context (EOWC)</p>
<blockquote>
<p>我實在不會把這個翻譯成中文 XD，以下簡稱它為 EOWC，</p>
<p>名字中有著 expected，假如你還記得高三的統計學，</p>
<p>就可以猜的到它可能隱含著期望值的概念在裡面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c(w_i ,d1) = Count of word w_i in d1</div><div class="line"></div><div class="line">|d1| = Total counts of words in d1 (d2 的部分就不重複了)</div></pre></td></tr></table></figure>
<p>$$<br>d1=(x_1, …x_N), \quad x_i = \frac{c(w_i ,d1)}{|d1|}<br>$$</p>
<p>$$<br>d2=(y_1, …y_N), \quad y_i = \frac{c(w_i ,d2)}{|d2|}<br>$$</p>
<p>$$<br>sim(d1,d2) = d1.d2 = \sum_{i=1}^{N}(x_i \times y_i)<br>$$</p>
<p>x_i 會是每個字(w_i)在各自的 pseudo document 裡面出的次數（count），</p>
<p>再去除以 document 裡面的總次數。</p>
<p>我們得到的值就會是 w_i 這個字，出現在這個 pseudo document 中的頻率。</p>
<blockquote>
<p>這是個 normalize 過的數值，所以將 x_1 加到 x_N 會是 1</p>
</blockquote>
<p>兩個向量的 dot product 就會是 similarity。</p>
<blockquote>
<p>dot product 的算法是這樣子， a = (1,2,1), b = (3, 3, 3)</p>
<p>a.b = 1<em>3+2</em>3+1*3 = 12</p>
</blockquote>
<p>聽起來是蠻直觀的，</p>
<p>這代表兩個 document 中出現的詞相同頻率越高，</p>
<p>兩個 context 就越相近。</p>
<p>儘管 EOWC 給了我們對相似度相當直觀的感受，</p>
<p>還是要小心這裡面有兩個問題：</p>
<ul>
<li><p>假如有其中一個詞的頻率在各個 document 出現次數超級高，那就會判定這兩個 context 有很高的相似度，就算其他詞重複頻率都很低也是一樣，這可能不會是我們想要的結果。 </p>
<ul>
<li>舉個很簡單的例子，假設藍綠兩派支持者互相叫囂，內文可能充斥著大量個幹幹幹幹，但彼此針對其攻擊對象的角度可能會很不同，但因為幹出現的頻率實在太高，所以 EOWC 會判定這兩個 context 有著高相似度。</li>
</ul>
</li>
<li><p>對所有字都一視同仁。</p>
<ul>
<li>舉例來說 “the” 跟 “cat”， “cat”能帶給我們的資訊會比 “the” 來的多，但他們的權重卻是一樣的。</li>
</ul>
</li>
<li><p>鑑於以上原因，我們再來看看有沒有什麼更好的方法。</p>
</li>
</ul>
<h3 id="Improving-EOWC-with-Retrieval-Heuristics"><a href="#Improving-EOWC-with-Retrieval-Heuristics" class="headerlink" title="Improving EOWC with Retrieval Heuristics"></a>Improving EOWC with Retrieval Heuristics</h3><p>兩個問題的解法：</p>
<ul>
<li><p>It favors matching one frequent term very well over matching more distinct terms.</p>
<ul>
<li>Sublinear transformation of Term Frequency (TF)</li>
</ul>
</li>
<li><p>It treats every word equally (overlap on “the” isn’t as<br>so meaningful as overlap on “eats”).</p>
<ul>
<li>Reward matching a rare word: IDF term weighting</li>
</ul>
</li>
</ul>
<p>先來看怎麼解決單一個詞擁有超高重複次數的問題，</p>
<p>TF transformation 其實就是把原本對應到的次數，轉換成另一個更合理的次數而已。</p>
<p>舉例來說：</p>
<p>我們可以把超過 1 的都 mapping 到 1 去， 0 的就是 0。</p>
<p>光用想的都知道上面這一個會丟失掉許多資料給我們的訊息，</p>
<p>所以接下來我們找到一個更合理的方式來做 TF transformation ，</p>
<p>叫做： BM25 Transformation。</p>
<blockquote>
<p>小小科普一下，雖然 tf-idf 應該是大一就會的東西 XD</p>
<p>BM25 通常指的是 Okapi BM25，是一個搜尋引擎中的 ranking function，</p>
<p>BM 指的是 best match，它是由 BM11 以及 BM15 結合起來的，</p>
<p>不過起始點由 0 移至 1，所以從 26 變成了 25，</p>
<p>這就是 BM25 的由來。</p>
<p>還想更瞭解 BM11 和 BM15 的話可以看下方的補充資料：</p>
<p><a href="http://xapian.org/docs/bm25.html" target="_blank" rel="external">The BM25 Weighting Scheme</a></p>
</blockquote>
<p>假設輸入為 x，輸出為 y：</p>
<p>$$<br>y = BM25(x)<br>$$</p>
<p>更進一步看 BM25 這個算法的話：</p>
<p>$$<br>y = \frac{(k+1)x}{x+k}<br>$$</p>
<p>k 是我們可以自訂的數字，</p>
<p>可以簡單的看出來這個 y 最多無法超過 k+1，</p>
<p>如此便有效的將太多次數的詞都降到 k+1 了，</p>
<p>那問題就來了，k 要訂多少才合理呢？</p>
<p>暫且擱置這個問題，先來看原本 EOWC 的第二個問題：</p>
<blockquote>
<p>It treats every word equally (overlap on “the” isn’t as<br>so meaningful as overlap on “eats”).</p>
</blockquote>
<p>太常在所有文章中都出現的字，它的重要性應該要降低，</p>
<p>而鮮少出現的字應該要被提高，我們用的方法則是 IDF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">W 是我們要分析的詞</div><div class="line">M 為 documents 的總數</div><div class="line">k 為 W 出現在 documents 中的次數</div></pre></td></tr></table></figure>
<blockquote>
<p>舉個小例子：</p>
<p>假設全部有 A, B, C 三個 documents，</p>
<p>而 W 出現在 A, B 兩個 documents，</p>
</blockquote>
<p>情況會是 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">W = W</div><div class="line">M = 3</div><div class="line">k = 2</div></pre></td></tr></table></figure>
<p>再來看 IDF 的公式：</p>
<p>$$<br>IDF(W) = log(\frac{M+1}{k})<br>$$</p>
<blockquote>
<p>IDf = Inverse Document Frequency</p>
<p>原本是 字在所有 document 中出現的次數/ document 的總數</p>
<p>IDF 是將其反過來看，所以稱為 inverse document frequency</p>
</blockquote>
<p>可以看到，當 k 越大時， IDF 就會越小，</p>
<p>當 k 到達最大值（M），代表每個 document 都有出現 W ，</p>
<p>IDF(W)會趨近於零，讓 “the” “的” 這種每個 document 都可能會出現的字權重降低，</p>
<p>對於第二個問題而言，是一個相當簡單卻有效的方法。</p>
<p>最後，我們要將這兩個方法加進我們的 EOWC 中來優化它。</p>
<p>一口氣看這些公式會有點嚇人，</p>
<p>我偏好一步一步來理解它。</p>
<p>首先要來定義幾個符號：</p>
<p>$$d1=(x_1, …x_N)$$</p>
<blockquote>
<p>d1 就是 pseudo document，</p>
<p>裡面的 x 是一個個的 word</p>
</blockquote>
<p>$$b \in [0,1]$$</p>
<p>$$k \in [0,+\infty)$$</p>
<p>$$|d1| = length\,of\,d1$$</p>
<p>有了上述的定義後，先不要去深究他們有什麼意義，</p>
<p>因為要放在下面這個公式中，他們的定義才有用：</p>
<p>$$<br>BM25(w_i, d1) = \frac{(k+1)c(w_i, d1)}{c(w_i,d1)+k(1-b+b\times\frac{|d1|}{average(|d|)})}<br>$$</p>
<p>看似好像多了很多奇怪的符號，</p>
<p>但只要把上面那個 BM25 拿來對照一下：</p>
<p>$$<br>y = BM25() = \frac{(k+1)x}{x+k}<br>$$</p>
<p>就會發現其實它只是把 <code>c(w_i, d1)</code> 帶入 <code>x</code> 中，</p>
<p><code>k</code> 仍然是拿來控制整個 tf 轉換過後的上界；</p>
<p>你唯一需要注意的新東西是 <code>b</code>，</p>
<p>$$<br>k(1-b+b\times\frac{|d1|}{average(|d|)})<br>$$</p>
<p><code>average(|d|)</code>是為了 normalize 過長的 document，</p>
<p>我們希望不要因為不同長度的 document ，</p>
<p>得到差異過大的結果，</p>
<p>我的經驗是理解到他在做 normalize 之後，</p>
<p>就不要在糾結在上面太多，</p>
<p>就像很多時候我們取 log 就是真的讓圖比較平滑或好看而已（或者是在輸入是 1 的時候能得到 0 值）。</p>
<p>再來就看我們怎麼對 doument 裡面的每個 word 做 normalize 以及轉化：</p>
<p>$$<br>SUM =\sum^{N}_{j=1}(BM25(w_j, d1))<br>$$</p>
<p>$$<br>x_i = \frac{BM25(w_i, d1)}{SUM}<br>$$</p>
<p>$$<br>\sum^{N}_{i=1}x_i = 1<br>$$</p>
<p>分母是每個字的得分，分子則是該字的得分，</p>
<p>這樣做的好處是相加起來會等於 1，</p>
<p>裡面隱含著就是機率模型的概念。</p>
<blockquote>
<p>d2 的話就把 x 代換成 y，這裡不再重複寫一次</p>
</blockquote>
<p>最後就可以來算 similarity 了：</p>
<p>$$<br>sim(d1,d2) = \sum_{i=1}^{N}(IDF(w_i) \times x_i \times y_i)<br>$$</p>
<p>新的算法中在一定程度上矯正了前面敘述到的兩個問題:</p>
<ul>
<li><p>tf =&gt; 將在單一個 doucment 中重複次數過高的字給 normalize</p>
</li>
<li><p>idf =&gt; 將在每個 document 中都出現的字的權重給降低</p>
</li>
</ul>
<p>因為算是中的三個元素都介於 0 到 1，</p>
<p>所以結果也會落在 0 跟 1 之間。</p>
<h3 id="One-more-thing-Syntagmatic-Relations-optional"><a href="#One-more-thing-Syntagmatic-Relations-optional" class="headerlink" title="One more thing: Syntagmatic Relations(optional)"></a>One more thing: Syntagmatic Relations(optional)</h3><p>這一小節會更加的抽象一點，最後來看個有趣的小知識，</p>
<p>BM25 其實也能應用在 syntagmatic relation 上面，</p>
<p>前面有說到組合關係能夠從 correlated occurence 去找：</p>
<p>$$<br>IDF-weighted \quad d_1=(x_1 \times IDF(w_1), …, x_N \times IDF(w_N))<br>$$</p>
<p>原本的 x_i 只能表現他在同一個 docoument 裡面出現的頻率有多高，</p>
<p>（這裡是指經過 normalized BM25  transformation 的值）</p>
<p>但是我們不能說這個 x_i 與其對應的 w_i 是相關的（correlated），</p>
<p>因為有許多 common words（e.q: “the”, “的”) 也被包含在裡面，</p>
<p>但是我們前面有學過 idf 這個轉換法，</p>
<p>假如我們對每個 <code>x_i</code> 去乘上對應的 <code>idf(w_i)</code>，</p>
<p>就能得到去掉常用出現的字之後，真正與 w_i 相關的值了。</p>
<p>我第一時間看到這裡有點疑惑， </p>
<p>Syntagmatic relation 不是從 word 同時出現的機率去挖掘的嗎？</p>
<p>假設我們要看 a 出現的話，b 同時出現的機率是多少，</p>
<p>其實我們得到每個 word 在每個 document 中出現的機率後，</p>
<p>就能算出在 a 字出現的條件下，b 也同時有出現的機率了，</p>
<p>就只是要算個條件機率而已 XD，相當的直觀！</p>
<blockquote>
<p>這裡也只是我自己的推論，有錯的話也請不吝告知了</p>
</blockquote>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>總計六個禮拜的課程，目前是第一個禮拜。</p>
<p>其實寫筆記想要寫到其他人看得懂比上課來的吃力一些，</p>
<p>但同時帶給我的好處就是更深入了解自己所研究的內容，</p>
<p>雖然 tf-idf 是這樣簡單的東西，</p>
<p>但實際上了解它背後的概念，會發現它能運用的場合非常的廣泛。</p>
<p>Text mining 並不是一門太空人般的學問，</p>
<p>畢竟我們生活離不開文字的溝通、訊息的傳遞，</p>
<p>當你有能力去知識的載體上挖更多知識時，</p>
<p>何樂而不為呢？</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://xapian.org/docs/bm25.html" target="_blank" rel="external">The BM25 Weighting Scheme</a></p>
</li>
<li><p>數學之美 - 吳軍</p>
</li>
<li><p><a href="https://www.coursera.org/learn/text-mining/home/welcome" target="_blank" rel="external">Coursera: Text Mining and Analytics 來自於 伊利諾伊大學香檳分校</a></p>
</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/21/illinois-text-mining-week-2/" class="prev">PREV</a><a href="/2016/07/11/eslint-fxcking-setup/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'abalone0204';
var disqus_identifier = '2016/07/15/illinois-text-mining-week-1/';
var disqus_title = 'Text Mining &amp; Analysis： week 1';
var disqus_url = 'http://abalone0204.github.com/2016/07/15/illinois-text-mining-week-1/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//abalone0204.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://abalone0204.github.com">Tsung-Chen Ku</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-76858432-1",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5730240d682815d7"></script></body></html>